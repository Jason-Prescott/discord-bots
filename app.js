// token: ODkwOTA5MTE5OTkxNjcyODcz.YU2pxg.1m9kflZJHP94tWOsylvvMpZRGRU
// invitation link: https://discord.com/api/oauth2/authorize?client_id=890909119991672873&permissions=326417737792&scope=bot

const { SlashCommandBuilder } = require("@discordjs/builders");
const { REST } = require("@discordjs/rest");
const { Client, Intents, Message, Channel, Options, Cache } = require("discord.js");
const sqlite3 = require("sqlite3");
const config = require('./config.json');
const Sequelize = require('sequelize');
const Op = Sequelize.Op;
const fetch = require('node-fetch');
const { headers, method } = require('@discordjs/rest');


const client = new Client({ intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.DIRECT_MESSAGES, Intents.FLAGS.GUILD_MESSAGES], 
                              partials: ["MESSAGE","CHANNEL","GUILD_MEMBER","USER","REACTION"]});

const sequelize = new Sequelize('mydb', 'user', 'password', {
  host: 'localhost',
  dialect: 'sqlite',
  logging: true,
  // SQLite only
  storage: 'database.sqlite',
});
//Define the main table 'absences' with columns ['name','date','dayName','wholeDay']
const Absences = sequelize.define('absences', {
        name: {
          type: Sequelize.STRING, //loaded in from Message.Author as a String of [Surname Name]
          unique: false,
        },
        date: {
          type: Sequelize.DATEONLY, //date in a format of [YYYY-MM-dd]
          unique: false,
        },
        dayName: {
          type: Sequelize.STRING, //generated by a procedure to check for weekends and some string output options
          unique: false,
        },
        wholeDay: {
          type: Sequelize.DOUBLE,
          unique: false,
          defaultValue: 1,
          allowNull: false,
        },
        homeOffice: {
          type: Sequelize.INTEGER,
          unique: false,
          defaultValue: 0,
          allowNull: false,
        }  
});

//Define what is to be done when the bot connects to the server
client.on('ready', () => {

  //Synchronize the table Absences, establish a connection. If the table does not exist, create a new one.
  Absences.sync();

  console.log(`Logged in as ${client.user.tag}!`);
  });
  
  client.on('interactionCreate', async interaction => {
    if (!interaction.isCommand()) return;
  });

  //create a mydb database to work with the data in real-time
  let db = new sqlite3.Database('./mydb', (err) => {
    if (err) {
      console.error(err.message);
    }
    console.log('Connected to the mydb database.');
  });

  //A custom function to add specified amount of days to a set date
  function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    //result = dateFormat(result, 'dd-MM-yyyy');
    return result;
  }

  //a simple date formatting function
  function dateFormat(inputDate, format) {
  //parse the input date
  const date = new Date(inputDate);

  //extract the parts of the date
  const day = date.getDate();
  const month = date.getMonth() + 1;
  const year = date.getFullYear();    

  //replace the month
  format = format.replace("MM", month.toString().padStart(2,"0"));        

  //replace the year
  if (format.indexOf("yyyy") > -1) {
      format = format.replace("yyyy", year.toString());
  } else if (format.indexOf("yy") > -1) {
      format = format.replace("yy", year.toString().substr(2,2));
  }

  //replace the day
  format = format.replace("dd", day.toString().padStart(2,"0"));

  return format;
}

  //A custom function to count the difference of days between two dates (needed to create multiple records based of the date range)
  function subtractDays(day1, day2) {
    const date1 = new Date(day1);
    const date2 = new Date(day2);

    const diffTime = Math.abs(date2 - date1);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays;
  }

  function getTodayDate() {
      let timestamp = Date.now();
        let date_ob = new Date(timestamp);
        let date = date_ob.getDate();
        let month = date_ob.getMonth() + 1;
        let year = date_ob.getFullYear();
        
        let today = year + '-' + month + '-' + date
        return today;
  }

  //A custom function to set a dayName for the data for further informative purposes and validation of weekends
  function getDayName(inputDay) {
    let day = inputDay.getDay();
    let dayString = '';

    switch (day) {
      case 1: 
      dayString = 'Monday';
      break;
      case 2: 
      dayString = 'Tuesday';
      break;
      case 3: 
      dayString = 'Wednesday';
      break;
      case 4: 
      dayString = 'Thursday';
      break;
      case 5: 
      dayString = 'Friday';
      break;
      case 6: 
      dayString = 'Saturday';
      break;
      case 0: 
      dayString = 'Sunday';
      break;
      default: 'You did not enter a date.';
    }
    return dayString;
  }

  //A listener to newly created messages
  client.on("messageCreate", async Message => {
    if (Message.author.bot) return;
  
    //if the message starts with !count, do the following
    if (Message.content.includes('!count',)) {

      //Predefined channelID where to post replies to queries
      const testChannelId = '890905435824078888'

      //This will create an array of arguments behind the command
      const args = Message.content.slice(config.prefix.length).trim().split(' ');
      const command = args.shift().toLowerCase();
  
      let requestedName = args[0];
      let requestedMonth = args[1];
      let monthCode = '';
      let monthCzechName = '';
      let absenceDeclination = '';

      //This sets Czech month name for localization purposes for the message replies, can be extended by any other language options
      switch (requestedMonth) {
        case 'Jan':
          monthCode = '-01-';
          monthCzechName = 'Leden';
        break;
        case 'Feb':
          monthCode = '-02-';
          monthCzechName = 'Únor';
        break;
        case 'Mar':
          monthCode = '-03-';
          monthCzechName = 'Březen';
        break;
        case 'Apr':
          monthCode = '-04-';
          monthCzechName = 'Duben';
        break;
        case 'May':
          monthCode = '-05-';
          monthCzechName = 'Květen';
        break;
        case 'Jun':
          monthCode = '-06-';
          monthCzechName = 'Červen';
        break;
        case 'Jul':
          monthCode = '-07-';
          monthCzechName = 'Červenec';
        break;
        case 'Aug':
          monthCode = '-08-';
          monthCzechName = 'Srpen';
        break;
        case 'Sep':
          monthCode = '-09-';
          monthCzechName = 'Září';
        break;
        case 'Oct':
          monthCode = '-10-';
          monthCzechName = 'Říjen';
        break;
        case 'Nov':
          monthCode = '-11-';
          monthCzechName = 'Listopad';
        break;
        case 'Dec':
          monthCode = '-12-';
          monthCzechName = 'Prosinec';
        break;
        default: '';
      }
      
      //Counts the number of absences for the required user in a specified month (excludes any weekend days)
      Absences.count(
        {
          distinct: true,
          col: 'absences.date',
          where: {
            'date': {[Op.substring]: monthCode},
            'name': {[Op.startsWith]: requestedName},
            [Op.and]: [
            {'dayName': {[Op.ne]: 'Saturday'}}, {'dayName': {[Op.ne]: 'Sunday'}}
            ]
        }
      }
      ).then(c => {

        //for the Czech localization defines the delication of the word Absence to change according to the number
        switch (c) {
          case 1: absenceDeclination = 'absenci';
          break;
          case 2: case 3: case 4: absenceDeclination = 'absence';
          break;
          default: absenceDeclination = '';
        }

        if (c == 0 || c >= 5) {
          absenceDeclination = 'absencí';
        }

        outputChannel = client.channels.fetch(testChannelId) ;
        outputChannel.then(channel => {channel.send(`The user ${requestedName} was absent in ${monthCzechName} ${c} days.`)});

      })

    }

    if (Message.content.includes('!update',)) {

      const testChannelId = '890905435824078888'

      const args = Message.content.slice(config.prefix.length).trim().split(' ');
      const command = args.shift().toLowerCase();
  
      let updateContent = args[0];

      const outputChannel = client.channels.fetch(testChannelId) ;
      outputChannel.then(channel => {channel.send(updateContent)});    

    }

    //A listener for the !absence command
    if (Message.content.includes('!absence',)) {

      let absenceText = '';
      let absenceName = '';

      //Output channelId definition
      const testChannelId = '890905435824078888'

      const args = Message.content.slice(config.prefix.length).trim().split(' ');
      const command = args.shift().toLowerCase();

      let isDate = new Date(args[1])
      

      let isNonDate = false;
      isNonDate = (isDate instanceof Date && isNaN(isDate))

      //if the command has a second argument, creates multiple records based on the date range provided
      if (args[1]) {
        
          const numberOfdays = subtractDays(args[0],args[1]) + 1;

            for (let i=0; i < numberOfdays; i++) {
              let absenceDay = addDays(new Date(args[0]), i)
              let absenceDayName = getDayName(absenceDay)
              let dbDate = dateFormat(absenceDay, 'yyyy-MM-dd')
              absenceDay = dateFormat(absenceDay,'dd-MM-yyyy')
              
              try {
              // equivalent to: INSERT INTO absences (name, date, dayName) values (?, ?, ?);
              const abs = await Absences.create({
                name: Message.author.username,
                date: dbDate,
                dayName: absenceDayName
              });
              console.log(abs.id, abs.name, abs.date, abs.dayName);

            } catch (error) {
                if (error.name === 'SequelizeUniqueConstraintError') {
                  return Message.reply('That tag already exists.');
                }
                return Message.reply('Something went wrong with adding the absence.');
            }
              
            }
            absenceText += '**' + dateFormat(args[0],'dd-MM-yyyy') + '**' + ' to ' + '**' + dateFormat(args[1],'dd-MM-yyyy') + '**'

            outputChannel = client.channels.fetch(testChannelId) ;
            outputChannel.then(channel => {channel.send(`Hello, I will be absent between ${absenceText}. Děkuji`)});
          }

      //if the command does not have a second argument of the second argument is not a date (now used for testing by inputting absences for other users [only 1 day])
      //if it only has the first argument, creates a single record for one day for the user calling the command
      //if the 2 argument is not a date, thus will be a String, creates a record for the user named in the second argument and the date provided instead
      if ((args[0] && !args[1]) || (args[0] && isNonDate)) {
        
        if (isNonDate) {
          absenceName = args[1]
        } 
        
        if (!args[1]) {
          absenceName = Message.author.username
        }
      
        let secondDate = args[0]
        const numberOfdays = subtractDays(args[0],secondDate) + 1;

            for (let i=0; i < numberOfdays; i++) {
              let absenceDay = addDays(new Date(args[0]), i)
              let absenceDayName = getDayName(absenceDay)
              let dbDate = dateFormat(absenceDay, 'yyyy-MM-dd')
              absenceDay = dateFormat(absenceDay,'dd-MM-yyyy')
              
              try {
              // equivalent to: INSERT INTO absences (name, date, dayName) values (?, ?, ?);
              const abs = await Absences.create({
                name: absenceName,
                date: dbDate,
                dayName: absenceDayName
              });
              console.log(abs.id, abs.name, abs.date, abs.dayName);

            } catch (error) {
                if (error.name === 'SequelizeUniqueConstraintError') {
                  return Message.reply('That tag already exists.');
                }
                return Message.reply('Something went wrong with adding the absence.');
            }
              outputChannel = client.channels.fetch(testChannelId) ;
              outputChannel.then(channel => {channel.send(`Hello, I request absence on **${absenceDayName}**, **${absenceDay}**.`)});
            }
              
      }

      //if the command does not have arguments, replies with a List of Users that will be missing for today
      if (!args[0]) {
        let today = getTodayDate()

        const missingPeople = await Absences.findAll({attributes: [Sequelize.fn('DISTINCT', Sequelize.col('name')), 'name'], where:{'date': {[Op.eq]: today}}})
        const missingPeopleString = missingPeople.map(m => m.name).join(', ') || 'No people set.';

        outputChannel = client.channels.fetch(testChannelId) ;
        outputChannel.then(channel => {channel.send(`Today will be missing these people: ${missingPeopleString}`)});
      }
    };

    if (Message.content.includes('!ho')) {

      //Output channelId definition
      const testChannelId = '890905435824078888'
      let absenceName = Message.author.username

      const args = Message.content.slice(config.prefix.length).trim().split(' ');
      const command = args.shift().toLowerCase();

      if (!args[0]) {
        let today = new Date(getTodayDate())
        let absenceDayName = getDayName(today)

        try {
          // equivalent to: INSERT INTO absences (name, date, dayName) values (?, ?, ?);
          const abs = await Absences.create({
            name: absenceName,
            date: today,
            dayName: absenceDayName,
            homeOffice: 1,
          });
          console.log(abs.id, abs.name, abs.date, abs.dayName, abs.homeOffice);

        } catch (error) {
            if (error.name === 'SequelizeUniqueConstraintError') {
              return Message.reply('That record already exists.');
            }
            return Message.reply('Something went wrong with adding the absence.');
        }
        outputChannel = client.channels.fetch(testChannelId) ;
        outputChannel.then(channel => {channel.send(`Hello, today I will be on HomeOffice.`)});
      }

      if ((args[0] && !args[1])) {
    
      let secondDate = args[0]
      const numberOfdays = subtractDays(args[0],secondDate) + 1;

          for (let i=0; i < numberOfdays; i++) {
            let absenceDay = addDays(new Date(args[0]), i)
            let absenceDayName = getDayName(absenceDay)
            let dbDate = dateFormat(absenceDay, 'yyyy-MM-dd')
            absenceDay = dateFormat(absenceDay,'dd-MM-yyyy')
            
            try {
            // equivalent to: INSERT INTO absences (name, date, dayName) values (?, ?, ?);
            const abs = await Absences.create({
              name: absenceName,
              date: dbDate,
              dayName: absenceDayName,
              homeOffice: 1,
            });
            console.log(abs.id, abs.name, abs.date, abs.dayName, abs.homeOffice);

          } catch (error) {
              if (error.name === 'SequelizeUniqueConstraintError') {
                return Message.reply('That record already exists.');
              }
              return Message.reply('Something went wrong with adding the absence.');
          }
            outputChannel = client.channels.fetch(testChannelId) ;
            outputChannel.then(channel => {channel.send(`Hello, I will be on Home Office on **${absenceDayName}**, **${absenceDay}**.`)});
          }
      } 

      
    };

    if (Message.content.includes('!pm')) {
      const args = Message.content.slice(config.prefix.length).trim().split(' ');
      const command = args.shift().toLowerCase();

      for (let k=5; k>0; k--) {
      client.users.fetch('824642377028993049').then((user) => {
        user.send(`Testing sending private messages. Finish testing in ${k} replicas.`);
       });
      }
       /* client.on('message', (msg) => {
        if (!msg.author.bot) msg.author.send('ok ' + msg.author.id);
       }); */
    }
    
    
  });

client.login("ODkwOTA5MTE5OTkxNjcyODcz.YU2pxg.1m9kflZJHP94tWOsylvvMpZRGRU");